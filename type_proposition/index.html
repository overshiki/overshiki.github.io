<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic|Source+Code+Pro:400,700" type="text/css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/celeste.min.css">

<link rel="icon" type="image/png" sizes="192x192" href="/assets/favicon.png">
<link rel="shortcut icon" href="/assets/favicon.ico">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/assets/apple-touch-icon.png">

   <title>dependent type</title>  
</head>
<body>
  <header>
<nav class="nav-main">
  <ul>
    <li class="hvr-underline-reveal"><a href="/">Home</a></li>
    <!-- <li class="logo"><a class="hvr-ripple-out" href="/">H</a></li> -->
    <!-- <li class="hvr-underline-reveal"><a href="/menu1/">Code blocks</a></li>
    <li class="hvr-underline-reveal"><a href="/menu2/">More goodies</a></li>
    <li class="hvr-underline-reveal"><a href="/menu3/">Tags</a></li> -->
  </ul>
</nav>
</header>


<!-- Content appended here -->
<div class="franklin-content"><p>So finally, I come to this point: how a theorem could be proved using a computer? Or, equivalently, how exactly an automated proof assistant works?</p>
<p>This question turns out to belong to the field of <code>constructive logic</code>, and is answered by the famous <code>Curry-Horward correspondence</code>, which links the field of <code>natural deduction</code> and <code>typed lambda calculus</code>. For more details of this astonishing discovery, please refer to <a href="https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf"><code>Propositions as Types</code></a> by Philip Wadler. &#40;You may also interested in his <a href="https://www.youtube.com/watch?v&#61;IOiZatlZtGU">talk</a>, and this <a href="https://www.cs.cmu.edu/~fp/courses/15814-f18/lectures/19-natded.pdf">lecture note</a>&#41;</p>
<p>In short, <code>Curry-Horward correspndance</code> says that a <code>Proposition</code> in <code>logic</code> is just a <code>Type</code> in <code>typed lambda calculus</code>, and a <code>Proof</code> of that <code>Proposition</code> is just a <code>term</code> belong to that <code>Type</code>.</p>
<p>How to understand this?</p>
<p>Intuitively speaking, a <code>proposition</code> is a claim, a claim of something to be true. So we can define a data type&#40;inductive data type as in dependent type theory&#41; which is in equivalent to the claim&#40;Or just define the data type recursively following the deduction definition of the claim&#41;. By doing so, if we can successfully implement an instance&#40;or <code>term</code>, or element&#41; of this data type, we are just proving the claim to be true&#33;&#40;i.e. the <code>proposition</code> is proved&#41;. On the contrary, if we can see the data type&#40;the set&#41; to be empty, then the <code>proposition</code> can not be proved. </p>
<p>Always, there are multiple ways to prove a <code>proposition</code>. Equivalently, there are multiple <code>terms</code>&#40;or element&#41; belonging to&#40;or inside&#41; the same <code>data type</code>. To prove a <code>proposition</code>, we just need one way of proving. Correspondingly, we just need to build one <code>term</code> belonging to that <code>data type</code>. That begins the story of automated proof assistant.</p>
<h3 id="dependent_type"><a href="#dependent_type" class="header-anchor">dependent type</a></h3>
<p>The <code>proposition as type</code> immediately requires that the type and the value both can be passed as arguments into functions. The formal demonstration of the reason remain next time. This time, I would like to give a brief demonstration of some use case of dependent type in proving.</p>
<p>For more detail of this demonstration, you may want to refer to this <a href="https://www.andrej.com/zapiski/ISRM-LOGRAC-2022/02-dependent-types.lagda.html">lecture</a>.</p>
<p>Let&#39;s begin with the definition of natural number:</p>
<pre><code class="language-Agda">data Fin : Nat -&gt; Set where
    zero&#39; : &#123;n : Nat&#125; -&gt; Fin n
    succ&#39; : &#123;n : Nat&#125; &#40;i : Fin n&#41; -&gt; Fin &#40;suc n&#41;</code></pre>
<p>what this does, is just to define any natural number as a types. More specifically, the type signature <code>Fin</code> itself is a function which receive instance of type <code>Nat</code> as parameter and return a type of <code>sort</code> <code>Set</code>. Which means, <code>Fin</code> combined with some instance <code>n</code> of type <code>Nat</code> would form a data type <code>Fin n</code>. &#40;quite similar to type family in <code>Haskell</code>&#41;</p>
<p>The data type has two constructors: </p>
<ul>
<li><p><code>zero&#39;</code> receives <code>n</code> of type <code>Nat</code> and treat it as instance of type <code>Fin n</code></p>
</li>
<li><p><code>succ&#39;</code> receives <code>n</code> of type <code>Nat</code> as well as <code>i</code> of type <code>Fin n</code> then treat it as instance of type <code>Fin &#40;suc n&#41;</code>. </p>
</li>
</ul>
<p>In this way, any natural numbers are corresponding to a data type. </p>
<p>Then if we want to prove that a natural number&#40;for example, 2&#41; exists, we just need to build an instance of type <code>Fin &#40;suc &#40;suc zero&#41;&#41;</code>. The proof is simple, since we already have one: <code>succ&#39; &#40;succ&#39; zero&#39;&#41;</code>, that&#39;s it&#33;</p>
<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Septimia Zenobia. Last modified: July 17, 2023.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
