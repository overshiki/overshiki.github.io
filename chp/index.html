<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
  
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic|Source+Code+Pro:400,700" type="text/css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/celeste.min.css">

<link rel="icon" type="image/png" sizes="192x192" href="/assets/favicon.png">
<link rel="shortcut icon" href="/assets/favicon.ico">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/assets/apple-touch-icon.png">

   <title>rehap</title>  
</head>
<body>
  <header>
<nav class="nav-main">
  <ul>
    <li class="hvr-underline-reveal"><a href="/">Home</a></li>
    <!-- <li class="logo"><a class="hvr-ripple-out" href="/">H</a></li> -->
    <!-- <li class="hvr-underline-reveal"><a href="/menu1/">Code blocks</a></li>
    <li class="hvr-underline-reveal"><a href="/menu2/">More goodies</a></li>
    <li class="hvr-underline-reveal"><a href="/menu3/">Tags</a></li> -->
  </ul>
</nav>
</header>


<!-- Content appended here -->
<div class="franklin-content"><h3 id="rehap"><a href="#rehap" class="header-anchor">rehap</a></h3>
\[
I = 
\begin{pmatrix}
1 & 0\\
0 & 1
\end{pmatrix}

X = 
\begin{pmatrix}
0 & 1\\
1 & 0
\end{pmatrix}

H = \frac{1}{\sqrt{2}}
\begin{pmatrix}
1 & 1\\
1 & -1
\end{pmatrix}
\]
\[
Y = 
\begin{pmatrix}
0 & -i\\
i & 0
\end{pmatrix}

Z = 
\begin{pmatrix}
1 & 0\\
0 & -1
\end{pmatrix}

S = 
\begin{pmatrix}
1 & 0\\
0 & i
\end{pmatrix}
\]
\[
CNOT = 
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0
\end{pmatrix}
\]
\[
\begin{aligned}
& XY = iZ \\
& YZ = iX \\
& ZX = iY \\
& YX = -iZ \\
& ZY = -iX \\
& XZ = -iY \\
& X^2 = Y^2 = Z^2 = I 
\end{aligned}
\]
<h3 id="gottesman-knill_theorem"><a href="#gottesman-knill_theorem" class="header-anchor">Gottesman-Knill Theorem:</a></h3>
<p>Quantum circuit consisting only of CNOT, H, S, measurement on computational basis can be simulated efficiently on a classical computer</p>
<h3 id="pauli_group"><a href="#pauli_group" class="header-anchor">Pauli Group</a></h3>
\[
\{ \pm 1, \pm i \} \{ I, X, Y, Z \}
\]
<h3 id="pauli_group_on_n_qubits"><a href="#pauli_group_on_n_qubits" class="header-anchor">Pauli Group on \(n\) qubits:</a></h3>
\[
P_n = 
\{ \pm 1, \pm i \} \{ 
  X^{a_1} Z^{b_1} \otimes
  X^{a_2} Z^{b_2} \otimes
  \cdots \otimes 
  X^{a_n} Z^{b_n}
  \}
\]
<h3 id="clifford_group_on_n_qubits"><a href="#clifford_group_on_n_qubits" class="header-anchor">Clifford Group on \(n\) qubits:</a></h3>
\[
C_n :
C_n P_n C_n^{\dagger} = P_n
\]
<p>up to complex phases.</p>
<p>more specifically</p>
\[
\forall p \in P_n, 
\forall c \in C_n,
cpc^{\dagger} \in P_n
\]
<p>up to complex phases.</p>
<h3 id="c_n_is_generated_by_h_s_and_cnot"><a href="#c_n_is_generated_by_h_s_and_cnot" class="header-anchor">\(C_n\) is generated by H, S and CNOT</a></h3>
<p>Intuitive example:</p>
\[
HXH^{\dagger} = Z 
\]
\[
CNOT(X \otimes I) CNOT^{\dagger} = X \otimes X
\]
<h3 id="stabilizer_group_of_quantum_state_ketpsi"><a href="#stabilizer_group_of_quantum_state_ketpsi" class="header-anchor">Stabilizer Group of quantum state \(\ket{\psi}\)</a></h3>
\[
\text{Stab}(\ket{\psi}) :
\forall U \in \text{Stab}(\ket{\psi}),
U\ket{\psi} = \ket{\psi}
\]
<h3 id="theorem_1_in_the_paper1"><a href="#theorem_1_in_the_paper1" class="header-anchor">Theorem 1 in the paper&#91;1&#93;.</a></h3>
<p>Given an n-qubits state \(\ket{\psi}\), the following are equivalent:</p>
<ul>
<li><p>\(\ket{\psi}\) can be obtained from \(\ket{0}^{\otimes n}\) by CNOT, H, S only</p>
</li>
<li><p>\(\ket{\psi}\) can be obtained from \(\ket{0}^{\otimes n}\) by CNOT, H, S and measurement gates only </p>
</li>
<li><p>\(\ket{\psi}\) is stabilized by exactly \(2^n\) Pauli operators</p>
</li>
<li><p>\(\ket{\psi}\) is uniquely determined by \(\text{Stab}(\ket{\psi}) \cap P_n\), i.e. the group of Pauli operators that stabilize \(\ket{\psi}\)</p>
</li>
</ul>
<h3 id="conclusion_from_group_theory"><a href="#conclusion_from_group_theory" class="header-anchor">conclusion from group theory</a></h3>
<p>Any finite group \(G\) has a generating set of size at most \(log_2|G|\)</p>
<p>if \(\ket{\psi}\) is a stabilizer states on n qubits, then the group \(\mathcal{S}_{P_n} := \text{Stab}(\ket{\psi}) \cap P_n\) of Pauli operators that stabilize \(\ket{\psi}\) has a generating set of size \(log_2 2^n = n\)</p>
<h4 id="textstabketpsi_is_a_group"><a href="#textstabketpsi_is_a_group" class="header-anchor">\(\text{Stab}(\ket{\psi})\) is a group</a></h4>
<p>if \(U\ket{\psi} = \ket{\psi}\), \(V\ket{\psi} = \ket{\psi}\) then \(U^{\dagger}\ket{\psi} = \ket{\psi}\), \(UV\ket{\psi} = \ket{\psi}\)</p>
<h4 id="mathcals_p_n_textstabketpsi_cap_p_n_is_a_group"><a href="#mathcals_p_n_textstabketpsi_cap_p_n_is_a_group" class="header-anchor">\(\mathcal{S}_{P_n} := \text{Stab}(\ket{\psi}) \cap P_n\) is a group</a></h4>
<p>indeed:</p>
\[
\text{Stab}(\ket{\psi}) \subset P_n
\]
<p>so </p>
\[
\text{Stab}(\ket{\psi}) \cap P_n = \text{Stab}(\ket{\psi})
\]
<p>which is a group</p>
<p>recall </p>
\[
C_n :
C_n P_n C_n^{\dagger} = P_n
\]
<p>up to complex phases.</p>
<p>So \(\mathcal{S}_{P_n}\) is our stabilizer groups &#40;which is a subgroup of Pauli group&#41;, \(C_n\) is the set of circuits that builds up clifford group &#40;i.e. clifford circuits&#41;</p>
<p>this tells us that clifford circuits transform a state stabilized by \(\mathcal{S}_{P_n}^{(i)} \sub P_n\) into another state stabilized by \(\mathcal{S}_{P_n}^{(j)} \sub P_n\), such states form a closed algebra structure.</p>
<p>It can be easily shown that there is one-one corespondence between \(C_n\) and the states.</p>
<p>Example:</p>
<img src="/assets/chp/chp_table.png" alt="">
<p>To show why:</p>
\[
\begin{aligned}
S\ket{\psi} &= \ket{\psi} \\
C_n S C_n^{\dagger} C_n \ket{\psi} &= C_n \ket{\psi}
\end{aligned}
\]
<p>i.e.</p>
\[
\frac
  {\vdash S \in \mathcal{S}_{P_n}(\ket{\psi})}
  {\vdash C_n S C_n^{\dagger} \in \mathcal{S}_{P_n}(C_n\ket{\psi})}
\]
<h3 id="revisiting_mathcals_p_n_textstabketpsi_cap_p_n"><a href="#revisiting_mathcals_p_n_textstabketpsi_cap_p_n" class="header-anchor">revisiting \(\mathcal{S}_{P_n} := \text{Stab}(\ket{\psi}) \cap P_n\)</a></h3>
\[
P_n = 
\{ \pm 1, \pm i \} \{ 
  X^{a_1} Z^{b_1} \otimes
  X^{a_2} Z^{b_2} \otimes
  \cdots \otimes 
  X^{a_n} Z^{b_n}
  \}
\]
\[
\mathcal{S}_{P_n} = 
\{ \pm 1\} \{ 
  X^{a_1} Z^{b_1} \otimes
  X^{a_2} Z^{b_2} \otimes
  \cdots \otimes 
  X^{a_n} Z^{b_n}
  \}
\]
<p>To show Why:</p>
<p>if we do not add the restriction, then:</p>
\[
\mathcal{S}_{P_n} \mathcal{S}_{P_n}^{\dagger} := (\pm i)^2 \{\}\{\}^{\dagger} = -I^{\otimes n}
\]
<p>is not unitary, which is forbidden.</p>
<p>Example:</p>
\[
\begin{aligned}
Y &= i X Z \\ 
SYS^{\dagger} &= iYZ = -X
\end{aligned}
\]
<h3 id="tablue_algorithm"><a href="#tablue_algorithm" class="header-anchor">Tablue Algorithm:</a></h3>
<p>Representing state generated by clifford circuits using its set of stabilizer generators: \(\mathcal{S}_{P_n}\)</p>
<p>Example:</p>
\[
\begin{aligned}
S :& X \to Y
  & Z \to Z \\

H : & X \to Z 
    & Z \to X \\

CNOT : & X_1 \to X_1 X_2 
       & X_2 \to X_2 \\
       & Z_1 \to Z_1 
       & Z_2 \to Z_1 Z_2 \\

X : & X \to X & Z \to -Z \\
Y : & X \to -X & Z \to -Z
\end{aligned}
\]
<p>For \(n\) qubits states, \(\mathcal{S}_{P_n}\) contains \(n\) Pauli strings, each Pauli string can be represented using \(2n\) bits.</p>
\[
\begin{pmatrix}
X_{11} & \cdots & X_{1n} & | & Z_{11} & \cdots & Z_{1n} & | & r_1 \\
\vdots & & \vdots & | & \vdots & & \vdots & | & \vdots \\
X_{n1} & \cdots & X_{nn} & | & Z_{n1} & \cdots & Z_{nn} & | & r_n  \\
\end{pmatrix}
\begin{matrix} 
   R_1 \\ \vdots \\ R_n 
\end{matrix}
\]
<p>each row represents a stabilizer.</p>
<p>Example:</p>
<p>2-qubit \(\ket{00}\):</p>
\[
\begin{pmatrix}
0 & 0 & | & 1 & 0 & | & 0 \\
0 & 0 & | & 0 & 1 & | & 0  \\
\end{pmatrix}
\begin{matrix} 
   R_1 \\ R_2 
\end{matrix}
\]
<p>the group multiply operation can be done with XOR:</p>
\[
[g_{R_1} * g_{R_2}]_{rep} := R_1 \oplus R_2
\]
\[\begin{aligned}
\oplus: 
& 0 \oplus 0 = 0 & & I I = I \\ 
& 0 \oplus 1 = 1 & & I P = P \\
& 1 \oplus 0 = 1 & & P I = P\\
& 1 \oplus 1 = 0 & & P P = I
\end{aligned}
\]
<p>two row operation can be safely applied without disturbing the state&#40;i.e. the symmetry introduced with this algebra structure&#41;</p>
<ul>
<li><p>row sum with XOR</p>
</li>
<li><p>row swap</p>
</li>
</ul>
<h3 id="update_rule_for_cnot_h_s"><a href="#update_rule_for_cnot_h_s" class="header-anchor">update rule for CNOT, H, S</a></h3>
<p>to be continue </p>
<h3 id="update_rule_for_measurement"><a href="#update_rule_for_measurement" class="header-anchor">update rule for measurement:</a></h3>
<p>suppose we have a single measurement on computational basis onto qubit \(a\): \(Z_a\)</p>
<p>check if \(\exist k, X_{ka}=1\) in the tablue:</p>
<h4 id="if_yes"><a href="#if_yes" class="header-anchor">if yes:</a></h4>
<p>the measurement is random.</p>
<h5 id="we_can_reduce_the_number_of_such_k_to_be_exactly_one"><a href="#we_can_reduce_the_number_of_such_k_to_be_exactly_one" class="header-anchor">we can reduce the number of such \(k\) to be exactly one:</a></h5>
<p>if there is another \(p\) s.t. \(X_{pa}=1\), we can:</p>
<p>do \(R_p = R_k \oplus R_p\) so that \(X_{pa}\) is canceled out.</p>
<h4 id="then_we_know"><a href="#then_we_know" class="header-anchor">then we know</a></h4>
<ul>
<li><p>\(\frac{1}{2}\) probability, \(m=0 \to r_k=0\)</p>
</li>
<li><p>\(\frac{1}{2}\) probability, \(m=1 \to r_k=1\)</p>
</li>
<li><p>set:</p>
<ul>
<li><p>\(Z_{ka}:=1\)</p>
</li>
<li><p>\(X_{ka}:=0\)</p>
</li>
</ul>
</li>
</ul>
<h4 id="if_no"><a href="#if_no" class="header-anchor">if no:</a></h4>
<p>the measurement is determinant.</p>
\[
\forall k, R_k Z_a = Z_a R_k 
\]
<p>\(\pm Z_a\) is also a stabilizer of \(\ket{\psi}\)</p>
<p>but \(+1\) or \(-1\)?</p>
\[
\exist \{i, j, k .. l\} s.t. \prod_{p \in \{i, j, k .. l\}} R_p = Z_a \text{or} -Z_a
\]
<p>how to get this?</p>
\[
R'_i = (X_{i1} \cdots X_{in} | Z_{i1} \cdots Z_{in})
\]
<p>we need to solve:</p>
\[
R' B = Z_a
\]
<p>solving this equation using Gaussian elimination requires \(\mathcal{O}(n^3)\)</p>
<h3 id="chp_improvement"><a href="#chp_improvement" class="header-anchor">CHP improvement</a></h3>
<h4 id="destabilizer"><a href="#destabilizer" class="header-anchor">destabilizer</a></h4>
<ul>
<li><p>let \(R_1 \cdots R_n\) s.t. \(R_i\) \(R_j\) commute</p>
</li>
<li><p>let \(R_{n+1} \cdots R_{2n}\) is the stabilizer group</p>
</li>
<li><p>let \(R_i, i \in \{1 ... n\}\) anticommutes with \(R_{n+i}\) and commutes with all others</p>
</li>
</ul>
<h4 id="the_update_rule_for_stabilizers_also_works_for_destabilizers"><a href="#the_update_rule_for_stabilizers_also_works_for_destabilizers" class="header-anchor">the update rule for stabilizers also works for destabilizers</a></h4>
<h4 id="using_destabilizer_to_help_keeping_track_of_phases"><a href="#using_destabilizer_to_help_keeping_track_of_phases" class="header-anchor">using destabilizer to help keeping track of phases</a></h4>
<p>recall </p>
\[
\exist \{i, j, k .. l\} s.t. \prod_{p \in \{i, j, k .. l\}} R_p = Z_a \text{or} -Z_a
\]
<p>\(Z_a\) will anticommute with \(R_i, i \in \{1 .. n\}\) iff \({i+n}\) is in the generator list of \(\{i, j, k .. l\}\) to produce \(\pm Z_a\)</p>
<p>Demo:</p>
\[
\begin{aligned}
& R_i R_{i+n} = (-1) R_{i+n} R_{i} \\
& \text{suppose:} Z_a = R_i R_j R_k ... R_l \\
\end{aligned} 
\]
\[
\begin{aligned}
Z_a R_{i+n} & = R_i R_j R_k ... R_l R_{i+n} \\
&= R_i R_{i+n} R_j R_k ... R_l \\
&= (-1) R_{i+n} R_i R_j R_k ... R_l
\end{aligned}
\]
<p>the procedure is simple</p>
<ul>
<li><p>scan all the destabilizer generators, to see if it is anticommute with \(Z_a\)</p>
<ul>
<li><p>if so, then the corresponding stabilizer generator is in the generator list </p>
</li>
<li><p>if not, it is not in the generator list </p>
</li>
</ul>
</li>
<li><p>using all the generator in the generator list to produce \(Z_a\), the corresponding phase is what we need</p>
</li>
</ul>
<p>This algorithm is of order \(\mathcal{O}(n^2)\)</p>
<h4 id="reference"><a href="#reference" class="header-anchor">reference</a></h4>
<p>&#91;1&#93; S. Aaronson and D. Gottesman, “Improved Simulation of Stabilizer Circuits”.</p>
<p>&#91;2&#93; &quot;An Introduction to Stabilizer Circuit Simulation&quot;</p>
<p>&#91;3&#93; V. Gheorghiu, “Efficient simulation of quantum computers: the Gottesman-Knill theorem or an application of group theory to quantum information &#40;part 2&#41;,” . . ..</p>
<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Septimia Zenobia. Last modified: June 12, 2025.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
  </body>
</html>
